---
source: typechecker/src/type_check/type_evaluator.rs
description: "1: from typing import TypeVar, Generic, Sequence\n2: from logging import Logger\n3: \n4: T = TypeVar('T')\n5: \n6: def first(l: Sequence[T]) -> T:\n7:     return l[0]\n8: \n9: # class LoggedVar(Generic[T]):\n10: #     def __init__(self, value: T, name: str, logger: Logger) -> None:\n11: #         self.name = name\n12: #         self.logger = logger\n13: #         self.value = value\n14: #\n15: #     def set(self, new: T) -> None:\n16: #         self.log('Set ' + repr(self.value))\n17: #         self.value = new\n18: #\n19: #     def get(self) -> T:\n20: #         self.log('Get ' + repr(self.value))\n21: #         return self.value\n22: #\n23: #     def log(self, message: str) -> None:\n24: #         self.logger.info('{}: {}'.format(self.name, message))\n"
expression: result
input_file: typechecker/test_data/inputs/basic_generics.py
---
Line 4: T = TypeVar('T')

Expr types in the line --->:
        "TypeVar('T')" => Type

---
Line 7:     return l[0]

Expr types in the line --->:
        "l[0]" => Class(ClassType { details: Class { name: "Sequence", declaration_path: DeclarationPath { module_name: [TYPESHED].stdlib/typing.pyi", node: Node { start: 15280, end: 15813 } }, methods: ["__getitem__", "__getitem__", "index", "count", "__contains__", "__iter__", "__reversed__"], special: false }, type_parameters: [Unknown] })

---

